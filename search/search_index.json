{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LTL f 2DFA is a tool that transforms an LTL f or a PLTL f formula into a minimal Deterministic Finite state Automaton (DFA) using MONA . It is also available online at http://ltlf2dfa.diag.uniroma1.it . Prerequisites This tool uses MONA for the generation of the DFA. Hence, you should first install MONA with all its dependencies on your system following the instructions here . This tool is also based on the following libraries: lark-parser 0.9.0 sympy 1.6.1 They are automatically added while installing LTL f 2DFA. Install from PyPI : pip install ltlf2dfa or, from source ( master branch): pip install git+https://github.com/whitemech/LTLf2DFA.git or, clone the repository and install: git clone https://github.com/whitemech/LTLf2DFA.git cd ltlf2dfa pip install . How To Use Parse an LTL f formula: from ltlf2dfa.parser.ltlf import LTLfParser parser = LTLfParser () formula_str = \"G(a -> X b)\" formula = parser ( formula_str ) # returns an LTLfFormula print ( formula ) # prints \"G(a -> X (b))\" Or, parse a PLTL f formula: from ltlf2dfa.parser.pltlf import PLTLfParser parser = PLTLfParser () formula_str = \"H(a -> Y b)\" formula = parser ( formula_str ) # returns a PLTLfFormula print ( formula ) # prints \"H(a -> Y (b))\" Translate a formula to the corresponding DFA automaton: dfa = formula . to_dfa () print ( dfa ) # prints the DFA in DOT format Features Syntax and parsing support for the following formal languages: Propositional Logic; Linear Temporal Logic on Finite Traces; Pure-Past Linear Temporal Logic on Finite Traces. Conversion from LTL f /PLTL f formula to MONA (First-order Logic) NOTE : LTL f 2DFA accepts either LTL f formulas or PLTL f formulas, i.e., formulas that have only past, only future or none operators. Tests To run tests: tox To run only the code tests: tox -e py3.7 To run only the code style checks: tox -e flake8 Docs To build the docs: mkdocs build To view documentation in a browser: mkdocs serve and then go to http://localhost:8000 License LTL f 2DFA is released under the GNU Lesser General Public License v3.0 or later (LGPLv3+). Copyright 2018-2020 WhiteMech @ Sapienza University Citing If you are interested in this tool, and you use it in your own work, please consider citing it. Author Francesco Fuggitti","title":"Home"},{"location":"#prerequisites","text":"This tool uses MONA for the generation of the DFA. Hence, you should first install MONA with all its dependencies on your system following the instructions here . This tool is also based on the following libraries: lark-parser 0.9.0 sympy 1.6.1 They are automatically added while installing LTL f 2DFA.","title":"Prerequisites"},{"location":"#install","text":"from PyPI : pip install ltlf2dfa or, from source ( master branch): pip install git+https://github.com/whitemech/LTLf2DFA.git or, clone the repository and install: git clone https://github.com/whitemech/LTLf2DFA.git cd ltlf2dfa pip install .","title":"Install"},{"location":"#how-to-use","text":"Parse an LTL f formula: from ltlf2dfa.parser.ltlf import LTLfParser parser = LTLfParser () formula_str = \"G(a -> X b)\" formula = parser ( formula_str ) # returns an LTLfFormula print ( formula ) # prints \"G(a -> X (b))\" Or, parse a PLTL f formula: from ltlf2dfa.parser.pltlf import PLTLfParser parser = PLTLfParser () formula_str = \"H(a -> Y b)\" formula = parser ( formula_str ) # returns a PLTLfFormula print ( formula ) # prints \"H(a -> Y (b))\" Translate a formula to the corresponding DFA automaton: dfa = formula . to_dfa () print ( dfa ) # prints the DFA in DOT format","title":"How To Use"},{"location":"#features","text":"Syntax and parsing support for the following formal languages: Propositional Logic; Linear Temporal Logic on Finite Traces; Pure-Past Linear Temporal Logic on Finite Traces. Conversion from LTL f /PLTL f formula to MONA (First-order Logic) NOTE : LTL f 2DFA accepts either LTL f formulas or PLTL f formulas, i.e., formulas that have only past, only future or none operators.","title":"Features"},{"location":"#tests","text":"To run tests: tox To run only the code tests: tox -e py3.7 To run only the code style checks: tox -e flake8","title":"Tests"},{"location":"#docs","text":"To build the docs: mkdocs build To view documentation in a browser: mkdocs serve and then go to http://localhost:8000","title":"Docs"},{"location":"#license","text":"LTL f 2DFA is released under the GNU Lesser General Public License v3.0 or later (LGPLv3+). Copyright 2018-2020 WhiteMech @ Sapienza University","title":"License"},{"location":"#citing","text":"If you are interested in this tool, and you use it in your own work, please consider citing it.","title":"Citing"},{"location":"#author","text":"Francesco Fuggitti","title":"Author"},{"location":"authors/","text":"Credits Maintainer Francesco Fuggitti < fuggitti@diag.uniroma1.it > Contributors None yet. Why not be the first ?","title":"Credits"},{"location":"authors/#credits","text":"","title":"Credits"},{"location":"authors/#maintainer","text":"Francesco Fuggitti < fuggitti@diag.uniroma1.it >","title":"Maintainer"},{"location":"authors/#contributors","text":"None yet. Why not be the first ?","title":"Contributors"},{"location":"changelog/","text":"History 1.0.1 (2020-07-03) Introduce optional argument to to_dfa() method for DFA in MONA output Add parsing support for LTLfLast() and PLTLfStart() keywords Some fixes Increase code coverage 1.0.0.post0 (2020-06-05) Include *.lark files in the package build New online version: http://ltlf2dfa.diag.uniroma1.it/ . 1.0.0 (2020-05-20) Refinement of all the grammars. Extensive improvement of the parsing. Introduce interfaces and class hierarchy for the logic modules. Several bug fixes and introduce testing. Introduce of docs. Introduce Continuous Integration. Refactor translation feature. Replace parsing library PLY with Lark. 0.2.2 (2019-09-25) Online version: http://ltlf2dfa.diag.uniroma1.it/ . 0.2.0 (2019-09-03) 0.1.3 (2018-07-22) 0.1.0 (2018-07-18) First release on PyPI.","title":"Change Log"},{"location":"changelog/#history","text":"","title":"History"},{"location":"changelog/#101-2020-07-03","text":"Introduce optional argument to to_dfa() method for DFA in MONA output Add parsing support for LTLfLast() and PLTLfStart() keywords Some fixes Increase code coverage","title":"1.0.1 (2020-07-03)"},{"location":"changelog/#100post0-2020-06-05","text":"Include *.lark files in the package build New online version: http://ltlf2dfa.diag.uniroma1.it/ .","title":"1.0.0.post0 (2020-06-05)"},{"location":"changelog/#100-2020-05-20","text":"Refinement of all the grammars. Extensive improvement of the parsing. Introduce interfaces and class hierarchy for the logic modules. Several bug fixes and introduce testing. Introduce of docs. Introduce Continuous Integration. Refactor translation feature. Replace parsing library PLY with Lark.","title":"1.0.0 (2020-05-20)"},{"location":"changelog/#022-2019-09-25","text":"Online version: http://ltlf2dfa.diag.uniroma1.it/ .","title":"0.2.2 (2019-09-25)"},{"location":"changelog/#020-2019-09-03","text":"","title":"0.2.0 (2019-09-03)"},{"location":"changelog/#013-2018-07-22","text":"","title":"0.1.3 (2018-07-22)"},{"location":"changelog/#010-2018-07-18","text":"First release on PyPI.","title":"0.1.0 (2018-07-18)"},{"location":"contributing/","text":"Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps and credit will always be given. If you need support, want to report/fix a bug, ask for/implement features, you can check the Issues page or submit a Pull request . For any other kinds of feedback, you can contact one of the authors by email.","title":"How to contribute"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps and credit will always be given. If you need support, want to report/fix a bug, ask for/implement features, you can check the Issues page or submit a Pull request . For any other kinds of feedback, you can contact one of the authors by email.","title":"Contributing"},{"location":"grammars/","text":"Grammars Grammars used by the Lark parser to parse Propositional Logic, LTL f and PLTL f . Propositional Logic pl.lark start: propositional_formula ?propositional_formula: prop_equivalence ?prop_equivalence: prop_implication (EQUIVALENCE prop_implication)* ?prop_implication: prop_or (IMPLY prop_or)* ?prop_or: prop_and (OR prop_and)* ?prop_and: prop_not (AND prop_not)* ?prop_not: NOT* prop_wrapped ?prop_wrapped: prop_atom | LSEPARATOR propositional_formula RSEPARATOR ?prop_atom: atom | prop_true | prop_false atom: SYMBOL_NAME prop_true: TRUE prop_false: FALSE LSEPARATOR: \"(\" RSEPARATOR: \")\" EQUIVALENCE: \"<->\" | \"<=>\" IMPLY: \"->\" | \"=>\" OR: \"||\" | \"|\" AND: \"&&\" | \"&\" NOT: \"!\" | \"~\" SYMBOL_NAME: /(\\w+)|(\".*\")/ TRUE.2: /(?i:true)/ FALSE.2: /(?i:false)/ %ignore /\\s+/ LTL f ltlf.lark start: ltlf_formula ?ltlf_formula: ltlf_equivalence ?ltlf_equivalence: ltlf_implication (EQUIVALENCE ltlf_implication)* ?ltlf_implication: ltlf_or (IMPLY ltlf_or)* ?ltlf_or: ltlf_and (OR ltlf_and)* ?ltlf_and: ltlf_until (AND ltlf_until)* ?ltlf_until: ltlf_release (UNTIL ltlf_release)* ?ltlf_release: ltlf_unaryop (RELEASE ltlf_unaryop)* ?ltlf_unaryop: ltlf_always | ltlf_eventually | ltlf_next | ltlf_weak_next | ltlf_not | ltlf_wrapped ?ltlf_always: ALWAYS ltlf_unaryop ?ltlf_eventually: EVENTUALLY ltlf_unaryop ?ltlf_next: NEXT ltlf_unaryop ?ltlf_weak_next: WEAK_NEXT ltlf_unaryop ?ltlf_not: NOT ltlf_unaryop ?ltlf_wrapped: ltlf_atom | LSEPARATOR ltlf_formula RSEPARATOR ?ltlf_atom: ltlf_symbol | ltlf_true | ltlf_false | ltlf_last ltlf_symbol: SYMBOL_NAME ltlf_true: prop_true ltlf_false: prop_false ltlf_last: LAST // Operators must not be part of a word UNTIL.2: /U(?=[^a-z]|$)/ RELEASE.2: /R(?=[^a-z]|$)/ ALWAYS.2: /G(?=[^a-z]|$)/ EVENTUALLY.2: /F(?=[^a-z]|$)/ NEXT.2: /X(?=[^a-z]|$)/ WEAK_NEXT.2: /WX(?=[^a-z]|$)/ LAST.2: /(?i:last)/ // Symbols cannot contain uppercase letters, because these are reserved SYMBOL_NAME: /[a-z][a-z0-9_]*/ %ignore /\\s+/ %import .pl.prop_true -> prop_true %import .pl.prop_false -> prop_false %import .pl.NOT -> NOT %import .pl.OR -> OR %import .pl.AND -> AND %import .pl.EQUIVALENCE -> EQUIVALENCE %import .pl.IMPLY -> IMPLY %import .pl.LSEPARATOR -> LSEPARATOR %import .pl.RSEPARATOR -> RSEPARATOR PLTL f pltlf.lark start: pltlf_formula ?pltlf_formula: pltlf_equivalence ?pltlf_equivalence: pltlf_implication (EQUIVALENCE pltlf_implication)* ?pltlf_implication: pltlf_or (IMPLY pltlf_or)* ?pltlf_or: pltlf_and (OR pltlf_and)* ?pltlf_and: pltlf_since (AND pltlf_since)* ?pltlf_since: pltlf_unaryop (SINCE pltlf_unaryop)* ?pltlf_unaryop: pltlf_historically | pltlf_once | pltlf_before | pltlf_not | pltlf_wrapped ?pltlf_historically: HISTORICALLY pltlf_unaryop ?pltlf_once: ONCE pltlf_unaryop ?pltlf_before: BEFORE pltlf_unaryop ?pltlf_not: NOT pltlf_unaryop ?pltlf_wrapped: pltlf_atom | LSEPARATOR pltlf_formula RSEPARATOR ?pltlf_atom: pltlf_symbol | pltlf_true | pltlf_false | pltlf_start pltlf_symbol: SYMBOL_NAME pltlf_true: prop_true pltlf_false: prop_false pltlf_start: START // Operators must not be part of a word SINCE.2: /S(?=[^a-z]|$)/ HISTORICALLY.2: /H(?=[^a-z]|$)/ ONCE.2: /O(?=[^a-z]|$)/ BEFORE.2: /Y(?=[^a-z]|$)/ START.2: /(?i:start)/ // Symbols cannot contain uppercase letters, because these are reserved SYMBOL_NAME: /[a-z][a-z0-9_]*/ %ignore /\\s+/ %import .pl.prop_true -> prop_true %import .pl.prop_false -> prop_false %import .pl.NOT -> NOT %import .pl.OR -> OR %import .pl.AND -> AND %import .pl.EQUIVALENCE -> EQUIVALENCE %import .pl.IMPLY -> IMPLY %import .pl.LSEPARATOR -> LSEPARATOR %import .pl.RSEPARATOR -> RSEPARATOR","title":"Grammars"},{"location":"grammars/#grammars","text":"Grammars used by the Lark parser to parse Propositional Logic, LTL f and PLTL f .","title":"Grammars"},{"location":"grammars/#propositional-logic","text":"pl.lark start: propositional_formula ?propositional_formula: prop_equivalence ?prop_equivalence: prop_implication (EQUIVALENCE prop_implication)* ?prop_implication: prop_or (IMPLY prop_or)* ?prop_or: prop_and (OR prop_and)* ?prop_and: prop_not (AND prop_not)* ?prop_not: NOT* prop_wrapped ?prop_wrapped: prop_atom | LSEPARATOR propositional_formula RSEPARATOR ?prop_atom: atom | prop_true | prop_false atom: SYMBOL_NAME prop_true: TRUE prop_false: FALSE LSEPARATOR: \"(\" RSEPARATOR: \")\" EQUIVALENCE: \"<->\" | \"<=>\" IMPLY: \"->\" | \"=>\" OR: \"||\" | \"|\" AND: \"&&\" | \"&\" NOT: \"!\" | \"~\" SYMBOL_NAME: /(\\w+)|(\".*\")/ TRUE.2: /(?i:true)/ FALSE.2: /(?i:false)/ %ignore /\\s+/","title":"Propositional Logic"},{"location":"grammars/#ltlf","text":"ltlf.lark start: ltlf_formula ?ltlf_formula: ltlf_equivalence ?ltlf_equivalence: ltlf_implication (EQUIVALENCE ltlf_implication)* ?ltlf_implication: ltlf_or (IMPLY ltlf_or)* ?ltlf_or: ltlf_and (OR ltlf_and)* ?ltlf_and: ltlf_until (AND ltlf_until)* ?ltlf_until: ltlf_release (UNTIL ltlf_release)* ?ltlf_release: ltlf_unaryop (RELEASE ltlf_unaryop)* ?ltlf_unaryop: ltlf_always | ltlf_eventually | ltlf_next | ltlf_weak_next | ltlf_not | ltlf_wrapped ?ltlf_always: ALWAYS ltlf_unaryop ?ltlf_eventually: EVENTUALLY ltlf_unaryop ?ltlf_next: NEXT ltlf_unaryop ?ltlf_weak_next: WEAK_NEXT ltlf_unaryop ?ltlf_not: NOT ltlf_unaryop ?ltlf_wrapped: ltlf_atom | LSEPARATOR ltlf_formula RSEPARATOR ?ltlf_atom: ltlf_symbol | ltlf_true | ltlf_false | ltlf_last ltlf_symbol: SYMBOL_NAME ltlf_true: prop_true ltlf_false: prop_false ltlf_last: LAST // Operators must not be part of a word UNTIL.2: /U(?=[^a-z]|$)/ RELEASE.2: /R(?=[^a-z]|$)/ ALWAYS.2: /G(?=[^a-z]|$)/ EVENTUALLY.2: /F(?=[^a-z]|$)/ NEXT.2: /X(?=[^a-z]|$)/ WEAK_NEXT.2: /WX(?=[^a-z]|$)/ LAST.2: /(?i:last)/ // Symbols cannot contain uppercase letters, because these are reserved SYMBOL_NAME: /[a-z][a-z0-9_]*/ %ignore /\\s+/ %import .pl.prop_true -> prop_true %import .pl.prop_false -> prop_false %import .pl.NOT -> NOT %import .pl.OR -> OR %import .pl.AND -> AND %import .pl.EQUIVALENCE -> EQUIVALENCE %import .pl.IMPLY -> IMPLY %import .pl.LSEPARATOR -> LSEPARATOR %import .pl.RSEPARATOR -> RSEPARATOR","title":"LTLf"},{"location":"grammars/#pltlf","text":"pltlf.lark start: pltlf_formula ?pltlf_formula: pltlf_equivalence ?pltlf_equivalence: pltlf_implication (EQUIVALENCE pltlf_implication)* ?pltlf_implication: pltlf_or (IMPLY pltlf_or)* ?pltlf_or: pltlf_and (OR pltlf_and)* ?pltlf_and: pltlf_since (AND pltlf_since)* ?pltlf_since: pltlf_unaryop (SINCE pltlf_unaryop)* ?pltlf_unaryop: pltlf_historically | pltlf_once | pltlf_before | pltlf_not | pltlf_wrapped ?pltlf_historically: HISTORICALLY pltlf_unaryop ?pltlf_once: ONCE pltlf_unaryop ?pltlf_before: BEFORE pltlf_unaryop ?pltlf_not: NOT pltlf_unaryop ?pltlf_wrapped: pltlf_atom | LSEPARATOR pltlf_formula RSEPARATOR ?pltlf_atom: pltlf_symbol | pltlf_true | pltlf_false | pltlf_start pltlf_symbol: SYMBOL_NAME pltlf_true: prop_true pltlf_false: prop_false pltlf_start: START // Operators must not be part of a word SINCE.2: /S(?=[^a-z]|$)/ HISTORICALLY.2: /H(?=[^a-z]|$)/ ONCE.2: /O(?=[^a-z]|$)/ BEFORE.2: /Y(?=[^a-z]|$)/ START.2: /(?i:start)/ // Symbols cannot contain uppercase letters, because these are reserved SYMBOL_NAME: /[a-z][a-z0-9_]*/ %ignore /\\s+/ %import .pl.prop_true -> prop_true %import .pl.prop_false -> prop_false %import .pl.NOT -> NOT %import .pl.OR -> OR %import .pl.AND -> AND %import .pl.EQUIVALENCE -> EQUIVALENCE %import .pl.IMPLY -> IMPLY %import .pl.LSEPARATOR -> LSEPARATOR %import .pl.RSEPARATOR -> RSEPARATOR","title":"PLTLf"},{"location":"references/","text":"References Linear Temporal Logic on finite traces (LTL f ) and Pure-Past Linear Temporal Logic on finite traces (PLTL f ) are two compelling well-known logical formalisms employed in several contexts, such as: Reasoning about Actions and Planning as a specification mechanism for temporally extended goals as constraints on plans as preferences and soft constraints for specifying multi-agent systems for specifying norms Business Process Specification and Verification Synthesis Reinforcement Learning for specifying rewards They are famous for their clarity and ease of use. A list of recommended readings: Giuseppe De Giacomo, Antonio Di Stasio, Francesco Fuggitti, and Sasha Rubin. \"Pure Past Linear Temporal and Dynamic Logic on Finite Traces\". IJCAI, 2020 Brafman Ronen, De Giacomo Giuseppe, and Patrizi Fabio. \"LTLf/LDLf Non-Markovian Rewards\". AAAI, 2018 Giuseppe De Giacomo and Moshe Y. Vardi. \"LTLf and LDLf synthesis under partial observability\". IJCAI, 2016 Giuseppe De Giacomo and Moshe Y. Vardi. \"Synthesis for LTL and LDL on finite traces\". IJCAI, 2015 Giuseppe De Giacomo and Moshe Y. Vardi. \"Linear Temporal Logic and Linear Dynamic Logic on Finite Traces\". IJCAI, 2013","title":"References"},{"location":"references/#references","text":"Linear Temporal Logic on finite traces (LTL f ) and Pure-Past Linear Temporal Logic on finite traces (PLTL f ) are two compelling well-known logical formalisms employed in several contexts, such as: Reasoning about Actions and Planning as a specification mechanism for temporally extended goals as constraints on plans as preferences and soft constraints for specifying multi-agent systems for specifying norms Business Process Specification and Verification Synthesis Reinforcement Learning for specifying rewards They are famous for their clarity and ease of use. A list of recommended readings: Giuseppe De Giacomo, Antonio Di Stasio, Francesco Fuggitti, and Sasha Rubin. \"Pure Past Linear Temporal and Dynamic Logic on Finite Traces\". IJCAI, 2020 Brafman Ronen, De Giacomo Giuseppe, and Patrizi Fabio. \"LTLf/LDLf Non-Markovian Rewards\". AAAI, 2018 Giuseppe De Giacomo and Moshe Y. Vardi. \"LTLf and LDLf synthesis under partial observability\". IJCAI, 2016 Giuseppe De Giacomo and Moshe Y. Vardi. \"Synthesis for LTL and LDL on finite traces\". IJCAI, 2015 Giuseppe De Giacomo and Moshe Y. Vardi. \"Linear Temporal Logic and Linear Dynamic Logic on Finite Traces\". IJCAI, 2013","title":"References"}]}